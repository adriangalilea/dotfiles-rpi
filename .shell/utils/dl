#!/bin/bash

# dl - Interactive Downloader for GitHub and YouTube
# Author: Adrian Galilea
# Version: 2.1
#
# Description:
# This script provides an interactive way to download files from GitHub directories
# and videos from YouTube. It uses gum for interactive prompts and supports both
# interactive and non-interactive modes.
#
# Usage:
#   dl [-i] [--force] [<path>] <url>
#     -i        Interactive mode
#     --force   Overwrite existing files
#     <path>    Optional destination path (default: current directory)
#     <url>     URL to download from (GitHub directory or YouTube video)
#
# Examples:
#   dl https://github.com/user/repo/tree/branch/path/to/dir
#   dl -i /downloads https://www.youtube.com/watch?v=VIDEO_ID
#
# Debug mode:
#   Set DEBUG=1 before running the script to enable debug mode

# Enable debug mode if DEBUG is set to 1
[[ "${DEBUG}" = "1" ]] && set -x

# Ensure the script is not being sourced
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    logs error "This script should not be sourced. Please run it as a standalone script."
    exit 1
fi

# Function to display help
show_help() {
    logs info "Usage: dl [-i] [--force] [<path>] <url>"
    logs info "  -i        Interactive mode"
    logs info "  --force   Overwrite existing files"
    logs info "  <path>    Optional destination path (default: current directory)"
    logs info "  <url>     URL to download from (GitHub directory or YouTube video)"
    logs info ""
    logs info "Examples:"
    logs info "  dl https://github.com/user/repo/tree/branch/path/to/dir"
    logs info "  dl -i /downloads https://www.youtube.com/watch?v=VIDEO_ID"
}

# Function to check if a command is available
command_exists() {
    type "$1" >/dev/null 2>&1
}

# Function to check required commands
check_required_commands() {
    local missing_commands=()
    for cmd in "$@"; do
        if ! command_exists "$cmd"; then
            missing_commands+=("$cmd")
        fi
    done

    if (( ${#missing_commands[@]} > 0 )); then
        logs error "The following required commands are missing:"
        for cmd in "${missing_commands[@]}"; do
            logs error "  - $cmd"
        done
        logs error "Please install them and try again."
        exit 1
    fi
}

# TODO make this part of the github-resolver and remove from here

parse_github_input() {
    local input=$1
    local -n ref_username=$2
    local -n ref_repo=$3
    local -n ref_branch=$4
    local -n ref_filepath=$5

    if [[ $input =~ ^git: ]]; then
        local repo=$(echo "$input" | cut -d':' -f2)
        ref_username=$(echo "$repo" | cut -d'/' -f1)
        ref_repo=$(echo "$repo" | cut -d'/' -f2)
        local branch_and_path=$(echo "$input" | cut -d':' -f3-)
        
        if [[ "$branch_and_path" == *:* ]]; then
            ref_branch=$(echo "$branch_and_path" | cut -d':' -f1)
            ref_filepath=$(echo "$branch_and_path" | cut -d':' -f2-)
        else
            ref_filepath=$branch_and_path
        fi
    elif [[ $input =~ ^https://github.com ]]; then
        ref_username=$(echo "$input" | sed -E 's|https://github.com/([^/]+)/.*|\1|')
        ref_repo=$(echo "$input" | sed -E 's|https://github.com/[^/]+/([^/]+)/blob/.*|\1|')
        ref_branch=$(echo "$input" | sed -E 's|.*/blob/([^/]+)/.*|\1|')
        ref_filepath=$(echo "$input" | sed -E 's|.*/blob/[^/]+/(.*)|\1|')
    else
        echo "Error: Invalid GitHub input format: $input" >&2
        return 1
    fi
}

# Function to download a single file from GitHub
download_github_file() {
    local username=$1
    local repo=$2
    local branch=$3
    local filepath=$4
    local force=$5

    local file_url="https://raw.githubusercontent.com/$username/$repo/$branch/$filepath"
    local filename=$(basename "$filepath")
    local curl_opts="-L"
    [ "$force" != "--force" ] && curl_opts+=" -C -"

    gum spin --spinner dot --title "Downloading $filename..." -- \
        curl $curl_opts "$file_url" -o "$filename"

    if [ $? -eq 0 ]; then
        logs info "‚úÖ Downloaded $filename"
        return 0
    else
        logs error "Failed to download $filename"
        return 1
    fi
}

download_from_github() {
    local username=$1
    local repo=$2
    local branch=$3
    local filepath=$4
    local dest_path=$5
    local interactive=$6
    local force=$7

    logs info "üê± $username/$repo [üåø $branch] üìÅ $filepath"
    mkdir -p "$dest_path"
    cd "$dest_path" || return 1

    local is_file=false
    [[ "$filepath" == *"."* ]] && is_file=true

    local url="https://codeload.github.com/$username/$repo/tar.gz/$branch"
    local tar_options="-xzv"
    local extract_dir="$repo-$branch"
    [ "$filepath" != "." ] && extract_dir+="/$filepath"

    local filter=""
    if [[ $is_file = true ]]; then
        if [[ $interactive = "-i" ]]; then
            logs warn "-i used but provided a specific file, nothing to choose."
        fi
        filter=$(basename "$filepath")
        extract_dir=$(dirname "$extract_dir")  # Remove the filename from extract_dir
    elif [[ $interactive = "-i" ]]; then
        local api_url="https://api.github.com/repos/$username/$repo/contents/$filepath?ref=$branch"
        local items
        items=$(curl -s "$api_url" | jq -r '.[] | [.name, .type] | @tsv')
        
        if [ -z "$items" ]; then
            logs error "Failed to fetch directory contents or directory is empty."
            return 1
        fi

        local selected_items
        selected_items=$(echo "$items" | awk -F'\t' '{printf "%s %s\n", $1, ($2=="file" ? "üìÑ" : "üìÅ")}' | gum choose --no-limit --header "‚¨áÔ∏è Select files and directories")
        selected_items=$(echo "$selected_items" | sed 's/ üìÑ$//' | sed 's/ üìÅ$//')
        
        if [ -n "$selected_items" ]; then
            filter=$(echo "$selected_items" | tr '\n' ' ')
        else
            logs info "No items selected. Exiting."
            return 0
        fi
    fi

    [ -n "$DEBUG" ] && echo "Using filter: $filter"

    gum spin --spinner dot --title "Downloading from $username/$repo..." -- \
        curl -L "$url" -o /tmp/repo.tar.gz

    local tar_command="tar $tar_options -f /tmp/repo.tar.gz"
    [ "$force" = "--force" ] && tar_command+=" --overwrite"

    if [ -n "$filter" ]; then
        for item in $filter; do
            tar_command+=" --wildcards '$extract_dir/$item'"
        done
    else
        tar_command+=" '$extract_dir'"
    fi

    local strip_components=$(echo "$extract_dir" | tr -cd '/' | wc -c)
    strip_components=$((strip_components + 1))
    tar_command+=" --strip-components=$strip_components"

    [ -n "$DEBUG" ] && echo "Extracting with command: $tar_command"

    local extraction_output
    extraction_output=$(bash -c "$tar_command" 2>&1)
    local extraction_status=$?

    rm /tmp/repo.tar.gz

    if [ $extraction_status -eq 0 ]; then
        logs info "‚úÖ Extracted files from $filepath"
        return 0
    else
        logs error "Extraction failed: $extraction_output"
        return 1
    fi
}

# Function to download YouTube video
download_youtube() {
    local url=$1 dest_path=$2 interactive=$3 force=$4
    if ! command_exists yt-dlp; then
        logs error "yt-dlp is not installed. It's required for YouTube downloads."
        if command_exists gum; then
            gum confirm "Do you want to continue without yt-dlp? (GitHub downloads will still work)" || exit 1
        else
            read -r -p "Do you want to continue without yt-dlp? (GitHub downloads will still work) [y/N] " REPLY
            [[ $REPLY =~ ^[Yy]$ ]] || exit 1
        fi
        return
    fi
    local format
    if [[ $interactive = "-i" ]]; then
        if command_exists gum; then
            format=$(gum choose "üé• Video (best quality)" "üîä Audio only (best quality)" --header "‚¨áÔ∏è Select format")
        else
            logs info "Select download format:"
            select format in "üé• Video (best quality)" "üîä Audio only (best quality)"; do
                break
            done
        fi
    else
        format="üé• Video (best quality)"
    fi
    mkdir -p "$dest_path"
    cd "$dest_path"
    local yt_dlp_options=""
    [[ $force = "--force" ]] && yt_dlp_options+=" --no-continue"
    if [[ $format = "üîä Audio only (best quality)" ]]; then
        gum spin --spinner dot --title "üîä Downloading audio..." -- yt-dlp -x --audio-format mp3 --audio-quality 0 $yt_dlp_options "$url"
        logs info "‚úÖ Downloaded audio from YouTube"
    else
        gum spin --spinner dot --title "üé• Downloading video..." -- yt-dlp -f bestvideo+bestaudio $yt_dlp_options "$url"
        logs info "‚úÖ Downloaded video from YouTube"
    fi
}

# Main function
main() {
    local interactive="" dest_path="" url="" force=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -i)
                interactive="-i"
                shift
                ;;
            --force)
                force="--force"
                shift
                ;;
            http*)
                url=$1
                shift
                ;;
            *)
                dest_path=$1
                shift
                ;;
        esac
    done

    [[ -z $url ]] && { show_help; exit 1; }
    [[ -z $dest_path ]] && dest_path="$(pwd)"

    # Check if required commands are available
    check_required_commands sed curl jq awk grep mkdir gum logs

    if parse_github_input "$url" username repo branch filepath; then
        download_from_github "$username" "$repo" "$branch" "$filepath" "$dest_path" "$interactive" "$force"
    elif [[ $url =~ ^https://(www\.)?youtube\.com ]]; then
        download_youtube "$url" "$dest_path" "$interactive" "$force"
    else
        logs error "Unsupported URL type. This script supports GitHub directories and YouTube videos."
        exit 1
    fi
}

# Check if gum is installed, if not, use fallback methods
command_exists gum || logs warn "gum is not installed. Some interactive features will be limited."

main "$@"

[[ "${DEBUG}" = "1" ]] && set +x # Disable debug mode if it was enabled
